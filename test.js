// Generated by CoffeeScript 1.4.0
(function() {
  var prelude;

  prelude = require('./prelude.js');

  prelude.installPrelude(global);

  describe("In prelude", function() {
    var fromAtoC, list, string;
    describe("each", function() {
      it("works on empty array", function() {
        return expect(each([], function() {})).toEqual([]);
      });
      it("changes given array", function() {
        return expect(each([[1, 5], [2, 6]], function(l) {
          return l.pop();
        })).toEqual([[1], [2]]);
      });
      it("iterates over strings", function() {
        var testTarget;
        testTarget = 0;
        expect(each('hello', function() {
          return ++testTarget;
        })).toEqual('hello');
        expect(testTarget).toEqual(5);
        return expect(each('', function() {})).toEqual('');
      });
      return it("iterates over objects", function() {
        var count;
        count = 4;
        each({
          a: 1,
          b: 2,
          c: 3
        }, function(n) {
          return count += n;
        });
        return expect(count).toEqual(10);
      });
    });
    describe("map", function() {
      it("works on arrays", function() {
        expect(map([], function() {})).toEqual([]);
        return expect(map([1, 2, 3], plus(1))).toEqual([2, 3, 4]);
      });
      it("works on strings", function() {
        return expect(map('abc', function(ch) {
          return ch.toUpperCase();
        })).toEqual('ABC');
      });
      it("works on objects", function() {
        var obj;
        obj = map({
          a: 1,
          b: 2
        }, times(2));
        expect(obj.a).toEqual(2);
        return expect(obj.b).toEqual(4);
      });
      it("works with an object mapping", function() {
        return expect(map(["one", "two", "three", "four"], toMap({
          one: 1,
          two: 2,
          three: 3,
          four: 4
        }))).toEqual([1, 2, 3, 4]);
      });
      return it("works with an array mapping", function() {
        var switches;
        switches = map({
          power: 1,
          light: 0
        }, toMap(['off', 'on']));
        expect(switches.power).toEqual('on');
        return expect(switches.light).toEqual('off');
      });
    });
    fromAtoC = function(x) {
      return ('a' <= x && x <= 'c');
    };
    describe("filter ", function() {
      it("works on arrays", function() {
        expect(filter([], id)).toEqual([]);
        return expect(filter([1, 2, 3, 4, 5], even)).toEqual([2, 4]);
      });
      it("works on strings", function() {
        return expect(filter('abcdefcf', fromAtoC)).toEqual('abcc');
      });
      return it("works on objects", function() {
        var obj;
        obj = filter({
          a: 1,
          b: 2
        }, equals(2));
        expect(obj.b).toEqual(2);
        return expect(obj.a != null).toBe(false);
      });
    });
    describe("reject", function() {
      it("works on arrays", function() {
        return expect(reject([1, 2, 3, 4, 5], even)).toEqual([1, 3, 5]);
      });
      it("works on strings", function() {
        return expect(reject('abcdefcf', fromAtoC)).toEqual('deff');
      });
      return it("works on objects", function() {
        var obj;
        obj = reject({
          a: 1,
          b: 2
        }, equals(2));
        expect(obj.a).toEqual(1);
        return expect(obj.b != null).toBe(false);
      });
    });
    describe("partition", function() {
      it("works on arrays", function() {
        var failed, passed, _ref;
        _ref = partition([49, 58, 76, 43, 88, 77, 90], function(x) {
          return x > 60;
        }), passed = _ref[0], failed = _ref[1];
        expect(passed).toEqual([76, 88, 77, 90]);
        return expect(failed).toEqual([49, 58, 43]);
      });
      it("works on objects", function() {
        var isTwo, notTwo, _ref;
        _ref = partition({
          a: 1,
          b: 2,
          c: 3
        }, equals(2)), isTwo = _ref[0], notTwo = _ref[1];
        expect(isTwo.b).toEqual(2);
        expect(notTwo.a).toEqual(1);
        expect(notTwo.c).toEqual(3);
        expect(notTwo.b != null).toBe(false);
        expect(isTwo.a != null).toBe(false);
        return expect(isTwo.c != null).toBe(false);
      });
      return it("works on strings", function() {
        return expect(partition('abcdefcf', fromAtoC)).toEqual(['abcc', 'deff']);
      });
    });
    describe("find", function() {
      it("works on arrays", function() {
        expect(find([3, 1, 4, 8, 6], even)).toEqual(4);
        return expect(find([3, 1], even)).toBe(void 0);
      });
      it("works on strings", function() {
        expect(find('abs', equals('b'))).toEqual('b');
        return expect(find('abs', equals('c'))).toBe(void 0);
      });
      return it("works on objects", function() {
        expect(find({
          a: 1,
          b: 2
        }, equals(2))).toEqual(2);
        return expect(find({
          a: 1,
          b: 2
        }, equals(3))).toBe(void 0);
      });
    });
    describe("pluck", function() {
      it("works on arrays", function() {
        return expect(pluck('num', [
          {
            num: 'one'
          }, {
            num: 'two'
          }
        ])).toEqual(['one', 'two']);
      });
      return it("works on objects", function() {
        var plucked;
        plucked = pluck('num', {
          a: {
            num: 1
          },
          b: {
            num: 2
          }
        });
        expect(plucked.a).toEqual(1);
        return expect(plucked.b).toEqual(2);
      });
    });
    list = [1, 2, 3, 4, 5];
    string = 'abcde';
    describe("head", function() {
      it("works on arrays", function() {
        expect(head(list)).toEqual(1);
        return expect((head([])) != null).toBe(false);
      });
      return it("works on strings", function() {
        expect(head(string)).toEqual('a');
        return expect((head('')) != null).toBe(false);
      });
    });
    describe("tail", function() {
      it("works on arrays", function() {
        expect(tail(list)).toEqual([2, 3, 4, 5]);
        return expect((tail([])) != null).toBe(false);
      });
      return it("works on strings", function() {
        expect(tail(string)).toEqual('bcde');
        return expect((tail('')) != null).toBe(false);
      });
    });
    describe("last", function() {
      it("works on arrays", function() {
        expect(last(list)).toEqual(5);
        return expect((last([])) != null).toBe(false);
      });
      return it("works on strings", function() {
        expect(last(string)).toEqual('e');
        return expect((last('')) != null).toBe(false);
      });
    });
    describe("initial", function() {
      it("works on arrays", function() {
        expect(initial(list)).toEqual([1, 2, 3, 4]);
        return expect((initial([])) != null).toBe(false);
      });
      return it("works on strings", function() {
        expect(initial(string)).toEqual('abcd');
        return expect((initial('')) != null).toBe(false);
      });
    });
    describe("empty", function() {
      it("works on arrays", function() {
        expect(empty([])).toBe(true);
        return expect(empty([1])).toBe(false);
      });
      it("works on objects", function() {
        expect(empty({})).toBe(true);
        return expect(empty({
          x: 1
        })).toBe(false);
      });
      return it("works on strings", function() {
        expect(empty('')).toBe(true);
        return expect(empty('1')).toBe(false);
      });
    });
    describe("values", function() {
      return it("works", function() {
        return expect(values({
          sadf: 1,
          asdf: 2,
          fdas: 3
        })).toEqual([1, 2, 3]);
      });
    });
    describe("keys", function() {
      it("works on objects", function() {
        return expect(keys({
          sadf: 1,
          asdf: 2,
          fdas: 3
        })).toEqual(['sadf', 'asdf', 'fdas']);
      });
      return it("works on arrays", function() {
        return expect(keys([1, 2, 3])).toEqual(['0', '1', '2']);
      });
    });
    describe("length", function() {
      it("works on arrays", function() {
        expect(len(list)).toEqual(5);
        return expect(len([])).toEqual(0);
      });
      it("works on objects", function() {
        expect(len({
          x: 1,
          y: 2,
          z: 3
        })).toEqual(3);
        return expect(len({})).toEqual(0);
      });
      return it("works on strings", function() {
        expect(len('abcd')).toEqual(4);
        return expect(len('')).toEqual(0);
      });
    });
    describe("cons ", function() {
      it("adds..an array", function() {
        return expect(cons(1, [2, 3])).toEqual([1, 2, 3]);
      });
      it("adds two givens..create an array", function() {
        return expect(cons(4, 5)).toEqual([4, 5]);
      });
      return it("works on strings", function() {
        return expect(cons('a', 'bc')).toEqual('abc');
      });
    });
    describe("append", function() {
      it("works on arrays", function() {
        expect(append([1, 2], [3, 4])).toEqual([1, 2, 3, 4]);
        return expect(append([1, 2], 3)).toEqual([1, 2, 3]);
      });
      return it("works on strings", function() {
        return expect(append('abc', 'def')).toEqual('abcdef');
      });
    });
    describe("join", function() {
      return it("works on arrays", function() {
        return expect(join(',', [1, 2, 3])).toEqual('1,2,3');
      });
    });
    describe("reverse", function() {
      it("works on arrays", function() {
        expect(reverse(list)).toEqual([5, 4, 3, 2, 1]);
        return expect(reverse([])).toEqual([]);
      });
      it("doesn't mutate given list", function() {
        return expect(list).toEqual([1, 2, 3, 4, 5]);
      });
      return it("works on strings", function() {
        expect(reverse('abcd')).toEqual('dcba');
        return expect(reverse('')).toEqual('');
      });
    });
    describe("fold", function() {
      it("works on arrays", function() {
        expect(fold(0, [1, 2, 3, 6], plus)).toEqual(12);
        return expect(fold(0, [], plus)).toEqual(0);
      });
      it("works on strings", function() {
        expect(fold('', 'abc', plus)).toEqual('abc');
        return expect(fold('', '', plus)).toEqual('');
      });
      return it("works on objects", function() {
        expect(fold(0, {
          a: 1,
          b: 2,
          c: 3,
          d: 6
        }, plus)).toEqual(12);
        return expect(fold(0, {}, plus)).toEqual(0);
      });
    });
    describe("fold1", function() {
      it("works on arrays", function() {
        return expect(fold1([1, 2, 3, 6], plus)).toEqual(12);
      });
      return it("works on strings", function() {
        return expect(fold1('abc', function(x, y) {
          return "" + x + " -> " + y;
        })).toEqual('a -> b -> c');
      });
    });
    describe("foldr", function() {
      return it("works", function() {
        return expect(foldr(9, [1, 2, 3, 4], minus)).toEqual(-1);
      });
    });
    describe("foldr1", function() {
      return it("works", function() {
        return expect(foldr1([1, 2, 3, 4, 9], minus)).toEqual(-1);
      });
    });
    describe("unfoldr", function() {
      return it("works", function() {
        return expect(unfoldr(10, function(x) {
          if (x === 0) {
            return null;
          } else {
            return [x, x - 1];
          }
        })).toEqual([10, 9, 8, 7, 6, 5, 4, 3, 2, 1]);
      });
    });
    describe("andList", function() {
      it("returns true for all true", function() {
        return expect(andList([true, 2 + 2 === 4])).toBe(true);
      });
      it("returns false if false occurs", function() {
        return expect(andList([true, true, false, true])).toBe(false);
      });
      return it("returns true for empty", function() {
        return expect(andList([])).toBe(true);
      });
    });
    describe("orList", function() {
      it("returns true for some true", function() {
        return expect(orList([false, false, false, true, false])).toBe(true);
      });
      it("returns false for all false", function() {
        return expect(orList([false, 2 + 2 === 3])).toBe(false);
      });
      return it("returns false for empty", function() {
        return expect(orList([])).toBe(false);
      });
    });
    describe("any", function() {
      it("works on arrays", function() {
        expect(any([1, 4, 3], even)).toBe(true);
        expect(any([1, 3, 7, 5], even)).toBe(false);
        return expect(any([], even)).toBe(false);
      });
      return it("works on strings", function() {
        expect(any('mmmhMmm', equals('M'))).toBe(true);
        expect(any('mmmhMmm', equals('Z'))).toBe(false);
        return expect(any('', equals('Z'))).toBe(false);
      });
    });
    describe("all", function() {
      it("works on arrays", function() {
        expect(all([2, 4, 6], even)).toBe(true);
        expect(all([2, 5, 6], even)).toBe(false);
        return expect(all([], even)).toBe(true);
      });
      return it("works on strings", function() {
        expect(all('MMMMMM', equals('M'))).toBe(true);
        expect(all('MMMmMM', equals('M'))).toBe(false);
        return expect(all('', equals('M'))).toBe(true);
      });
    });
    describe("unique", function() {
      it("works on arrays", function() {
        return expect(unique([1, 1, 2, 3, 3, 4, 5, 5, 5, 5, 5, 6, 6, 6, 6])).toEqual([1, 2, 3, 4, 5, 6]);
      });
      it("works on objects", function() {
        return expect(unique({
          a: 2,
          b: 3,
          c: 2
        })).toEqual([2, 3]);
      });
      return it("works on strings", function() {
        return expect(unique('aaabbbcccdd')).toEqual('abcd');
      });
    });
    describe("sort", function() {
      it("works on arrays", function() {
        expect(sort([3, 1, 5, 2, 4, 6])).toEqual([1, 2, 3, 4, 5, 6]);
        return expect(sort([])).toEqual([]);
      });
      return it("sorts numbers numerically not alphabetically", function() {
        return expect(sort([334, 12, 5, 2, 4999, 6])).toEqual([2, 5, 6, 12, 334, 4999]);
      });
    });
    describe("sortWith", function() {
      it("doesn't need a useful callback with empty list", function() {
        return expect(sortWith([], function() {})).toEqual([]);
      });
      return it("works", function() {
        var obj;
        obj = {
          one: 1,
          two: 2,
          three: 3
        };
        return expect(sortWith(['three', 'one', 'two'], compare(toMap(obj)))).toEqual(['one', 'two', 'three']);
      });
    });
    describe("sortBy", function() {
      return it("works", function() {
        var obj;
        obj = {
          one: 1,
          two: 2,
          three: 3
        };
        return expect(sortBy(['three', 'one', 'two'], toMap(obj))).toEqual(['one', 'two', 'three']);
      });
    });
    describe("compare", function() {
      return it("works", function() {
        expect(compare([1, 2, 3], [0, 1, 2, 3, 4, 5], function(x) {
          return x.length;
        })).toEqual(-1);
        expect(compare([1, 2, 3, 4, 5, 6, 7, 8, 9], [0, 1, 2, 3, 4, 5], function(x) {
          return x.length;
        })).toEqual(1);
        return expect(compare([1, 2, 3, 4], [4, 5, 6, 7], function(x) {
          return x.length;
        })).toEqual(0);
      });
    });
    describe("sum", function() {
      it("works on arrays", function() {
        expect(sum([1, 2, 3, 4])).toEqual(10);
        return expect(sum([])).toEqual(0);
      });
      return it("works on objects", function() {
        expect(sum({
          a: 1,
          b: 2,
          c: 3,
          d: 4
        })).toEqual(10);
        return expect(sum({})).toEqual(0);
      });
    });
    describe("product", function() {
      it("works on arrays", function() {
        expect(product([1, 2, 3, 4])).toEqual(24);
        return expect(product([])).toEqual(1);
      });
      return it("works on objects", function() {
        expect(product({
          a: 1,
          b: 2,
          c: 3,
          d: 4
        })).toEqual(24);
        return expect(product({})).toEqual(1);
      });
    });
    describe("mean", function() {
      it("works on arrays", function() {
        expect(mean([2, 3, 4, 5, 6])).toEqual(4);
        return expect(isItNaN(mean([]))).toBe(true);
      });
      return it("works on objects", function() {
        return expect(mean({
          a: 2,
          b: 3,
          c: 4,
          d: 5,
          e: 6
        })).toEqual(4);
      });
    });
    describe("median", function() {
      it("is not defined for empty", function() {
        return expect(median([])).toEqual(void 0);
      });
      it("works on odd number of elements", function() {
        return expect(median([4, 3, 2, 6, 5])).toEqual(4);
      });
      return it("works on even number of elements", function() {
        return expect(median([4, 5, 2, 3])).toEqual(3.5);
      });
    });
    describe("concat", function() {
      it("works on arrays", function() {
        expect(concat([[1, 2], [3, 4], [5, 6]])).toEqual([1, 2, 3, 4, 5, 6]);
        return expect(concat([])).toEqual([]);
      });
      return it("works on strings", function() {
        return expect(concat(['aa', 'bb', 'cc', 'dd'])).toEqual('aabbccdd');
      });
    });
    describe("concatMap", function() {
      it("works on arrays", function() {
        expect(concatMap([1, 2, 3], function(x) {
          var _i, _results;
          return (function() {
            _results = [];
            for (var _i = 1; 1 <= x ? _i <= x : _i >= x; 1 <= x ? _i++ : _i--){ _results.push(_i); }
            return _results;
          }).apply(this);
        })).toEqual([1, 1, 2, 1, 2, 3]);
        return expect(concatMap([], function() {})).toEqual([]);
      });
      return it("works on strings", function() {
        return expect(concatMap(['aa', 'bb', 'cc', 'dd'], function(x) {
          return x.toUpperCase();
        })).toEqual('AABBCCDD');
      });
    });
    describe("maximum", function() {
      it("works on arrays", function() {
        expect(maximum([1, 2, 6, 4, 5])).toEqual(6);
        return expect(maximum([])).toEqual(void 0);
      });
      return it("works on strings", function() {
        expect(maximum('abcdef')).toEqual('f');
        return expect(maximum(['charlie', 'dan', 'adam', 'bob'])).toEqual('dan');
      });
    });
    describe("minimum", function() {
      it("works on arrays", function() {
        expect(minimum([4, 3, 2, 6, 9])).toEqual(2);
        return expect(minimum([])).toEqual(void 0);
      });
      return it("works on strings", function() {
        expect(minimum('abcdef')).toEqual('a');
        return expect(minimum(['charlie', 'dan', 'adam', 'bob'])).toEqual('adam');
      });
    });
    describe("scan", function() {
      return it("works on arrays", function() {
        var res;
        expect(scan(4, [1, 2, 3], function(x, y) {
          return 2 * x + y;
        })).toEqual([4, 9, 20, 43]);
        expect((res = scan(0, [], plus)).length).toEqual(1);
        return expect(res).toEqual([0]);
      });
    });
    describe("scan1", function() {
      return it("works on arrays", function() {
        return expect(scan1([1, 2, 3, 4], plus)).toEqual([1, 3, 6, 10]);
      });
    });
    describe("scanr", function() {
      return it("works on arrays", function() {
        return expect(scanr(5, [1, 2, 3, 4], plus)).toEqual([15, 14, 12, 9, 5]);
      });
    });
    describe("scanr1", function() {
      return it("works on arrays", function() {
        return expect(scanr1([1, 2, 3, 4], plus)).toEqual([10, 9, 7, 4]);
      });
    });
    describe("replicate", function() {
      it("works", function() {
        expect(replicate(4, 3)).toEqual([3, 3, 3, 3]);
        return expect(replicate(0, 0)).toEqual([]);
      });
      return it("does not treat strings specially", function() {
        expect(replicate(4, 'a')).toEqual(['a', 'a', 'a', 'a']);
        return expect(replicate(0, 'a')).toEqual([]);
      });
    });
    describe("take", function() {
      it("works on arrays", function() {
        expect(take(3, [1, 2, 3, 4, 5])).toEqual([1, 2, 3]);
        expect(take(3, [])).toEqual([]);
        return expect(take(-1, [1, 2, 3, 4, 5])).toEqual([]);
      });
      return it("works on strings", function() {
        expect(take(2, string)).toEqual('ab');
        expect(take(3, '')).toEqual('');
        return expect(take(0, string)).toEqual('');
      });
    });
    describe("drop", function() {
      it("works on arrays", function() {
        expect(drop(3, [1, 2, 3, 4, 5])).toEqual([4, 5]);
        expect(drop(3, [])).toEqual([]);
        return expect(drop(0, [1, 2, 3, 4, 5])).toEqual([1, 2, 3, 4, 5]);
      });
      return it("works on strings", function() {
        expect(drop(2, string)).toEqual('cde');
        expect(drop(2, '')).toEqual('');
        return expect(drop(0, string)).toEqual('abcde');
      });
    });
    describe("splitAt", function() {
      it("works on arrays", function() {
        var res;
        expect(join('|', splitAt(3, [1, 2, 3, 4, 5]))).toEqual('1,2,3|4,5');
        expect((res = splitAt(3, [])).length).toEqual(2);
        expect(res[0]).toEqual([]);
        return expect(res[1]).toEqual([]);
      });
      return it("works on strings", function() {
        var res;
        expect(join('|', splitAt(3, 'abcde'))).toEqual('abc|de');
        expect((res = splitAt(3, '')).length).toEqual(2);
        expect(res[0]).toEqual('');
        return expect(res[1]).toEqual('');
      });
    });
    describe("takeWhile", function() {
      it("works on arrays", function() {
        expect(takeWhile([1, 3, 5, 4, 8, 7, 9], odd)).toEqual([1, 3, 5]);
        return expect(takeWhile([], odd)).toEqual([]);
      });
      return it("works on strings", function() {
        expect(takeWhile('mmmmmhmm', equals('m'))).toEqual('mmmmm');
        return expect(takeWhile('', equals('m'))).toEqual('');
      });
    });
    describe("dropWhile", function() {
      it("works on arrays", function() {
        expect(dropWhile([2, 4, 6, 7, 9, 10], even)).toEqual([7, 9, 10]);
        return expect(dropWhile([], odd)).toEqual([]);
      });
      return it("works on strings", function() {
        expect(dropWhile('mmmmmhmm', equals('m'))).toEqual('hmm');
        return expect(dropWhile('', equals('m'))).toEqual('');
      });
    });
    describe("span", function() {
      it("works on arrays", function() {
        var res;
        expect(join('|', span([2, 4, 6, 7, 9, 10], even))).toEqual('2,4,6|7,9,10');
        expect((res = span([], even)).length).toEqual(2);
        expect(res[0]).toEqual([]);
        return expect(res[1]).toEqual([]);
      });
      return it("works on strings", function() {
        var res;
        expect(join('|', span('mmmmmhmm', equals('m')))).toEqual('mmmmm|hmm');
        expect((res = span('', equals('m'))).length).toEqual(2);
        expect(res[0]).toEqual('');
        return expect(res[1]).toEqual('');
      });
    });
    describe("breakIt", function() {
      it("works on arrays", function() {
        var res;
        expect(join('|', breakIt([1, 2, 3, 4, 5], equals(3)))).toEqual('1,2|3,4,5');
        expect((res = breakIt([], even)).length).toEqual(2);
        expect(res[0]).toEqual([]);
        return expect(res[1]).toEqual([]);
      });
      return it("works on strings", function() {
        var res;
        expect(join('|', breakIt('mmmmmhmm', equals('h')))).toEqual('mmmmm|hmm');
        expect((res = breakIt('', equals('h'))).length).toEqual(2);
        expect(res[0]).toEqual('');
        return expect(res[1]).toEqual('');
      });
    });
    describe("elem", function() {
      it("works on arrays", function() {
        expect(elem(2, [1, 2, 3, 4, 5])).toBe(true);
        expect(elem(6, [1, 2, 3, 4, 5])).toBe(false);
        return expect(elem(3, [])).toBe(false);
      });
      return it("works on strings", function() {
        return expect(elem('a', 'bad')).toBe(true);
      });
    });
    describe("notElem", function() {
      it("works on arrays", function() {
        expect(notElem(0, [1, 2, 3, 4, 5])).toBe(true);
        expect(notElem(3, [1, 2, 3, 4, 5])).toBe(false);
        return expect(notElem(3, [])).toBe(true);
      });
      return it("works on strings", function() {
        return expect(notElem('z', 'bad')).toBe(true);
      });
    });
    describe("lookup", function() {
      it("works on objects", function() {
        expect(lookup('two', {
          two: 2
        })).toEqual(2);
        return expect((lookup('two', {})) != null).toBe(false);
      });
      return it("works on arrays", function() {
        return expect(lookup(2, [2, 3, 4])).toEqual(4);
      });
    });
    describe("call", function() {
      it("works on objects", function() {
        expect(call('four', {
          four: function() {
            return 4;
          }
        })).toEqual(4);
        return expect((call('four', {})) != null).toBe(false);
      });
      it("works on arrays", function() {
        return expect(call(1, [
          null, function() {
            return 4;
          }
        ])).toEqual(4);
      });
      return it("passes arguments along", function() {
        return expect(call('four', 6, {
          four: id
        })).toEqual(6);
      });
    });
    describe("listToObj", function() {
      return it("works", function() {
        expect(listToObj([['a', 'b'], ['c', 'd'], ['e', 1]])).toEqual({
          a: 'b',
          c: 'd',
          e: 1
        });
        return expect(listToObj([])).toEqual([]);
      });
    });
    describe("toMap", function() {
      return it("works", function() {
        return expect((toMap({
          one: 1,
          two: 2
        }))('two')).toEqual(2);
      });
    });
    describe("typeOf", function() {
      it("identifies String", function() {
        expect(typeOf(new String)).toEqual('String');
        return expect(typeOf("")).toEqual('String');
      });
      it("identifies Array", function() {
        return expect(typeOf([])).toEqual('Array');
      });
      it("identifies Object", function() {
        var Snake;
        expect(typeOf({})).toEqual('Object');
        Snake = (function() {

          function Snake() {}

          return Snake;

        })();
        return expect(typeOf(new Snake)).toEqual('Object');
      });
      it("identifies Number", function() {
        expect(typeOf(42)).toEqual('Number');
        return expect(typeOf(new Number)).toEqual('Number');
      });
      it("identifies Date", function() {
        return expect(typeOf(new Date)).toEqual('Date');
      });
      it("identifies RegExp", function() {
        expect(typeOf(/goal/g)).toEqual('RegExp');
        return expect(typeOf(new RegExp("goal"))).toEqual('RegExp');
      });
      return it("identifies Undefined and Null", function() {
        expect(typeOf(void 0)).toEqual('Undefined');
        return expect(typeOf(null)).toEqual('Null');
      });
    });
    describe("zip", function() {
      return it("works", function() {
        expect(zip([1, 2], [4, 5])).toEqual([[1, 4], [2, 5]]);
        return expect(zip([], [])).toEqual([]);
      });
    });
    describe("zipWith", function() {
      return it("works in the right order", function() {
        expect(zipWith([1, 2, 3], [2, 3, 4], minus)).toEqual([-1, -1, -1]);
        return expect(zipWith([], [], id)).toEqual([]);
      });
    });
    describe("zipAll", function() {
      return it("works", function() {
        expect(zipAll([1, 2, 3], [4, 5, 6], [7, 8, 9])).toEqual([[1, 4, 7], [2, 5, 8], [3, 6, 9]]);
        return expect(zipAll([], [])).toEqual([]);
      });
    });
    describe("zipAllWith", function() {
      return it("works", function() {
        expect(zipAllWith([1, 2, 3], [3, 2, 1], [1, 2, 3], function(x, y, z) {
          return x + y + z;
        })).toEqual([5, 6, 7]);
        return expect(zipAllWith([], [], [], [], id)).toEqual([]);
      });
    });
    describe("compose", function() {
      return it("works", function() {
        var addTwo, composed, minusOne, timesTwo;
        addTwo = function(x) {
          return x + 2;
        };
        timesTwo = function(x) {
          return x * 2;
        };
        minusOne = function(x) {
          return x - 1;
        };
        composed = compose(addTwo, timesTwo, minusOne);
        return expect(composed(3)).toEqual(9);
      });
    });
    describe("curry", function() {
      return it("works", function() {
        var add, addCurried;
        add = function(x, y, z) {
          return x + y + z;
        };
        addCurried = curry(add);
        expect((addCurried(4, 2))(3)).toEqual(9);
        return expect((addCurried(4))(2, 2)).toEqual(8);
      });
    });
    describe("partial", function() {
      var addAdd;
      addAdd = function(x, y, z) {
        return x + y + z;
      };
      it("curries", function() {
        var add9;
        add9 = partial(addAdd, 4, 5);
        return expect(add9(8)).toEqual(17);
      });
      it("curries multiple", function() {
        var add3;
        add3 = partial(addAdd, 3);
        return expect(add3(9, 5)).toEqual(17);
      });
      it("curries all arguments", function() {
        var add0;
        add0 = partial(addAdd);
        return expect(add0(0, 0, 17)).toEqual(17);
      });
      return it("curries 0 arguments", function() {
        var add17;
        add17 = partial(addAdd, 0, 0, 17);
        return expect(add17()).toEqual(17);
      });
    });
    describe("id ", function() {
      return it("works", function() {
        return expect(id(5)).toEqual(5);
      });
    });
    describe("flip", function() {
      it("works", function() {
        return expect((flip(minus))(5, 15)).toEqual(10);
      });
      return it("curries", function() {
        return expect(flip(minus, 5, 15)).toEqual(10);
      });
    });
    describe("fix", function() {
      it("works with one argument", function() {
        return expect((fix(function(fib) {
          return function(n) {
            if (n <= 1) {
              return 1;
            } else {
              return fib(n - 1) + fib(n - 2);
            }
          };
        }))(10)).toEqual(89);
      });
      return it("works with multiple arguments", function() {
        return expect((fix(function(fib) {
          return function(n, minus) {
            if (minus == null) {
              minus = 0;
            }
            if (n - minus <= 1) {
              return 1;
            } else {
              return fib(n, minus + 1) + fib(n, minus + 2);
            }
          };
        }))(10)).toEqual(89);
      });
    });
    describe("lines", function() {
      return it("works", function() {
        expect(lines('one\ntwo\nthree')).toEqual(['one', 'two', 'three']);
        return expect(lines('')).toEqual([]);
      });
    });
    describe("unlines", function() {
      return it("works", function() {
        expect(unlines(['one', 'two', 'three'])).toEqual('one\ntwo\nthree');
        return expect(unlines([])).toEqual('');
      });
    });
    describe("words", function() {
      it("works with single spaces", function() {
        expect(words('what is this')).toEqual(['what', 'is', 'this']);
        return expect(words('')).toEqual([]);
      });
      return it("works with multiple spaces", function() {
        return expect(words('what   is  this')).toEqual(['what', 'is', 'this']);
      });
    });
    describe("unwords", function() {
      return it("works", function() {
        expect(unwords(['what', 'is', 'this'])).toEqual('what is this');
        return expect(unwords([])).toEqual('');
      });
    });
    describe("max", function() {
      it("works on numbers", function() {
        return expect(max(2, 3)).toEqual(3);
      });
      return it("works on strings", function() {
        expect(max('a', 'b')).toEqual('b');
        return expect(max('adam', 'barbara')).toEqual('barbara');
      });
    });
    describe("min", function() {
      it("works on numbers", function() {
        return expect(min(9, 0)).toEqual(0);
      });
      return it("works on strings", function() {
        expect(min('a', 'b')).toEqual('a');
        return expect(min('adam', 'barbara')).toEqual('adam');
      });
    });
    describe("negate", function() {
      return it("works", function() {
        expect(negate(2)).toEqual(-2);
        expect(negate(-3)).toEqual(3);
        return expect(negate(0)).toEqual(0);
      });
    });
    describe("abs", function() {
      return it("works", function() {
        expect(abs(-4)).toEqual(4);
        expect(abs(4)).toEqual(4);
        return expect(abs(0)).toEqual(0);
      });
    });
    describe("signum", function() {
      return it("works", function() {
        expect(signum(8)).toEqual(1);
        expect(signum(82372.237272)).toEqual(1);
        expect(signum(0)).toEqual(0);
        expect(signum(-0)).toEqual(0);
        return expect(signum(-5.3)).toEqual(-1);
      });
    });
    describe("quot", function() {
      return it("works", function() {
        return expect(quot(-20, 3)).toEqual(-6);
      });
    });
    describe("rem", function() {
      return it("works like %", function() {
        expect(rem(-20, 3)).toEqual(-2);
        expect(rem(20, -3)).toEqual(2);
        return expect(rem(-20, -3)).toEqual(-2);
      });
    });
    describe("div", function() {
      return it("works", function() {
        return expect(div(-20, 3)).toEqual(-7);
      });
    });
    describe("mod", function() {
      return it("works (properly on negatives)", function() {
        expect(mod(-20, 3)).toEqual(1);
        return expect(mod(20, -3)).toEqual(-1);
      });
    });
    describe("recip", function() {
      return it("inverts", function() {
        return expect(recip(2)).toEqual(0.5);
      });
    });
    describe("pi", function() {
      return it("works", function() {
        return expect(pi).toEqual(3.141592653589793);
      });
    });
    describe("tau", function() {
      return it("works", function() {
        return expect(tau).toEqual(6.283185307179586);
      });
    });
    describe("exp", function() {
      return it("works", function() {
        return expect(exp(1)).toEqual(2.718281828459045);
      });
    });
    describe("sqrt", function() {
      return it("works", function() {
        return expect(sqrt(4)).toEqual(2);
      });
    });
    describe("ln", function() {
      return it("works", function() {
        return expect(ln(2)).toEqual(0.6931471805599453);
      });
    });
    describe("pow", function() {
      return it("works", function() {
        return expect(pow(-2, 2)).toEqual(4);
      });
    });
    describe("sin", function() {
      return it("works", function() {
        expect(sin(1)).toEqual(0.8414709848078965);
        return expect(sin(0)).toEqual(0);
      });
    });
    describe("tan", function() {
      return it("works", function() {
        expect(tan(1)).toEqual(1.5574077246549023);
        return expect(tan(0)).toEqual(0);
      });
    });
    describe("cos", function() {
      return it("works", function() {
        expect(cos(1)).toEqual(0.5403023058681398);
        return expect(cos(0)).toEqual(1);
      });
    });
    describe("acos", function() {
      return it("works", function() {
        return expect(acos(0.1)).toEqual(1.4706289056333368);
      });
    });
    describe("asin", function() {
      return it("works", function() {
        return expect(asin(1)).toEqual(1.5707963267948966);
      });
    });
    describe("atan", function() {
      return it("works", function() {
        return expect(atan(1)).toEqual(0.7853981633974483);
      });
    });
    describe("atan2", function() {
      return it("works", function() {
        return expect(atan2(1, 2)).toEqual(0.4636476090008061);
      });
    });
    describe("truncate", function() {
      it("rounds toward 0 (that is ceil on negatives)", function() {
        return expect(truncate(-1.5)).toEqual(-1);
      });
      return it("rounds toward 0 (that is floor on positives)", function() {
        return expect(truncate(1.5)).toEqual(1);
      });
    });
    describe("round", function() {
      return it("rounds unbiased", function() {
        expect(round(0.6)).toEqual(1);
        expect(round(0.5)).toEqual(1);
        return expect(round(0.4)).toEqual(0);
      });
    });
    describe("ceil", function() {
      return it("rounds up", function() {
        return expect(ceil(0.1)).toEqual(1);
      });
    });
    describe("floor", function() {
      return it("rounds down", function() {
        return expect(floor(0.9)).toEqual(0);
      });
    });
    describe("isItNaN", function() {
      return it("works", function() {
        expect(isItNaN(Math.sqrt(-1))).toBe(true);
        return expect(isItNaN('0')).toBe(false);
      });
    });
    describe("even", function() {
      return it("works", function() {
        expect(even(-2)).toBe(true);
        expect(even(7)).toBe(false);
        return expect(even(0)).toBe(true);
      });
    });
    describe("odd", function() {
      return it("works", function() {
        expect(odd(3)).toBe(true);
        expect(odd(-4)).toBe(false);
        return expect(odd(0)).toBe(false);
      });
    });
    describe("gcd", function() {
      it("works", function() {
        return expect(gcd(12, 18)).toEqual(6);
      });
      return it("works on negatives", function() {
        expect(gcd(-12, 18)).toEqual(6);
        expect(gcd(12, -18)).toEqual(6);
        return expect(gcd(-12, -18)).toEqual(6);
      });
    });
    describe("lcm", function() {
      it("works", function() {
        return expect(lcm(12, 18)).toEqual(36);
      });
      return it("works on negatives", function() {
        expect(lcm(12, -18)).toEqual(36);
        expect(lcm(-12, 18)).toEqual(36);
        return expect(lcm(-12, -18)).toEqual(36);
      });
    });
    describe("plus", function() {
      it("adds numbers", function() {
        return expect(plus(-2, 3)).toEqual(1);
      });
      return it("curries", function() {
        return expect((plus(-2))(3)).toEqual(1);
      });
    });
    describe("minus", function() {
      it("subtracts numbers", function() {
        return expect(minus(-2, 3)).toEqual(-5);
      });
      return it("curries", function() {
        return expect((minus(-2))(3)).toEqual(-5);
      });
    });
    describe("times", function() {
      it("multiplies numbers", function() {
        return expect(times(-2, 3)).toEqual(-6);
      });
      return it("curries", function() {
        return expect((times(-2))(3)).toEqual(-6);
      });
    });
    describe("over", function() {
      it("divides numbers", function() {
        return expect(over(-2, 3)).toEqual(-2 / 3);
      });
      return it("curries", function() {
        return expect((over(-2))(3)).toEqual(-2 / 3);
      });
    });
    return describe("equals", function() {
      it("compares numbers", function() {
        return expect(equals(3, 3)).toBe(true);
      });
      return it("curries", function() {
        return expect((equals(3))(3)).toBe(true);
      });
    });
  });

}).call(this);
