(function (that) {
if(typeof define !== 'function') {
  var define = function (x) {
    that.prelude = x;
  }
}
var module = {};
define(function () {

// Generated by CoffeeScript 1.4.0
(function() {
  var X, abs, acos, all, andList, any, append, asin, atan, atan2, average, breakIt, call, ceil, compare, compose, concat, concatMap, cons, cos, curry, div, drop, dropWhile, each, elem, empty, equals, even, exp, extend, filter, find, first, fix, flip, floor, fold, fold1, foldl, foldl1, foldr, foldr1, gcd, head, id, initial, installPrelude, isItNaN, join, keys, last, lcm, len, lines, listToObj, ln, lookup, map, max, maximum, mean, median, min, minimum, minus, mod, negate, notElem, odd, orList, over, partial, partition, phi, pi, pluck, plus, pow, prelude, product, quot, recip, reject, rem, replicate, reverse, round, scan, scan1, scanl, scanl1, scanr, scanr1, signum, sin, sort, sortBy, sortWith, span, splitAt, sqrt, sum, tail, take, takeWhile, tan, tau, times, toMap, truncate, typeOf, unfold, unfoldr, unique, unlines, unwords, values, words, zip, zipAll, zipAllWith, zipWith,
    __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; },
    __slice = [].slice,
    __hasProp = {}.hasOwnProperty;

  X = {};

  X.typeOf = typeOf = function(obj) {
    return {}.toString.call(obj);
  };

  X.toMap = toMap = function(obj) {
    return function(key) {
      return obj[key];
    };
  };

  X.each = each = function(xs, f) {
    var key, x, _i, _len;
    if (typeOf(xs) === '[object Object]') {
      for (key in xs) {
        x = xs[key];
        f(x);
      }
    } else {
      for (_i = 0, _len = xs.length; _i < _len; _i++) {
        x = xs[_i];
        f(x);
      }
    }
    return xs;
  };

  X.map = map = function(xs, f) {
    var key, res, result, type, x;
    type = typeOf(xs);
    if (type === '[object Object]') {
      res = {};
      for (key in xs) {
        x = xs[key];
        res[key] = f(x);
      }
      return res;
    } else {
      result = (function() {
        var _i, _len, _results;
        _results = [];
        for (_i = 0, _len = xs.length; _i < _len; _i++) {
          x = xs[_i];
          _results.push(f(x));
        }
        return _results;
      })();
      if (type === '[object String]') {
        return result.join('');
      } else {
        return result;
      }
    }
  };

  X.filter = filter = function(xs, f) {
    var key, result, type, x;
    type = typeOf(xs);
    if (type === '[object Object]') {
      result = {};
      for (key in xs) {
        x = xs[key];
        if (f(x)) {
          result[key] = x;
        }
      }
      return result;
    } else {
      result = (function() {
        var _i, _len, _results;
        _results = [];
        for (_i = 0, _len = xs.length; _i < _len; _i++) {
          x = xs[_i];
          if (f(x)) {
            _results.push(x);
          }
        }
        return _results;
      })();
      if (type === '[object String]') {
        return result.join('');
      } else {
        return result;
      }
    }
  };

  X.reject = reject = function(xs, f) {
    var key, result, type, x;
    type = typeOf(xs);
    if (type === '[object Object]') {
      result = {};
      for (key in xs) {
        x = xs[key];
        if (!f(x)) {
          result[key] = x;
        }
      }
      return result;
    } else {
      result = (function() {
        var _i, _len, _results;
        _results = [];
        for (_i = 0, _len = xs.length; _i < _len; _i++) {
          x = xs[_i];
          if (!f(x)) {
            _results.push(x);
          }
        }
        return _results;
      })();
      if (type === '[object String]') {
        return result.join('');
      } else {
        return result;
      }
    }
  };

  X.partition = partition = function(xs, f) {
    var failed, key, passed, type, x, _i, _len;
    type = typeOf(xs);
    if (type === '[object Object]') {
      passed = {};
      failed = {};
      for (key in xs) {
        x = xs[key];
        (f(x) ? passed : failed)[key] = x;
      }
    } else {
      passed = [];
      failed = [];
      for (_i = 0, _len = xs.length; _i < _len; _i++) {
        x = xs[_i];
        (f(x) ? passed : failed).push(x);
      }
      if (type === '[object String]') {
        passed = passed.join('');
        failed = failed.join('');
      }
    }
    return [passed, failed];
  };

  X.find = find = function(xs, f) {
    var key, x, _i, _len;
    if (typeOf(xs) === '[object Object]') {
      for (key in xs) {
        x = xs[key];
        if (f(x)) {
          return x;
        }
      }
    } else {
      for (_i = 0, _len = xs.length; _i < _len; _i++) {
        x = xs[_i];
        if (f(x)) {
          return x;
        }
      }
    }
    return void 0;
  };

  X.pluck = pluck = function(prop, xs) {
    var key, result, x, _i, _len, _results;
    if (typeOf(xs) === '[object Object]') {
      result = {};
      for (key in xs) {
        x = xs[key];
        if (x[prop] != null) {
          result[key] = x[prop];
        }
      }
      return result;
    } else {
      _results = [];
      for (_i = 0, _len = xs.length; _i < _len; _i++) {
        x = xs[_i];
        if (x[prop] != null) {
          _results.push(x[prop]);
        }
      }
      return _results;
    }
  };

  X.head = head = X.first = first = function(xs) {
    if (!xs.length) {
      return void 0;
    }
    return xs[0];
  };

  X.tail = tail = function(xs) {
    if (!xs.length) {
      return void 0;
    }
    return xs.slice(1);
  };

  X.last = last = function(xs) {
    if (!xs.length) {
      return void 0;
    }
    return xs.slice(-1)[0];
  };

  X.initial = initial = function(xs) {
    if (!xs.length) {
      return void 0;
    }
    return xs.slice(0, -1);
  };

  X.empty = empty = function(xs) {
    var x;
    if (typeOf(xs) === '[object Object]') {
      for (x in xs) {
        return false;
      }
      return true;
    }
    return !xs.length;
  };

  X.values = values = function(obj) {
    var key, x, _results;
    _results = [];
    for (key in obj) {
      x = obj[key];
      _results.push(x);
    }
    return _results;
  };

  X.keys = keys = function(obj) {
    var x, _results;
    _results = [];
    for (x in obj) {
      _results.push(x);
    }
    return _results;
  };

  X.len = len = function(xs) {
    if (typeOf(xs) === '[object Object]') {
      xs = values(xs);
    }
    return xs.length;
  };

  X.cons = cons = function(x, xs) {
    if (typeOf(xs) === '[object String]') {
      return x + xs;
    } else {
      return [x].concat(xs);
    }
  };

  X.append = append = function(xs, ys) {
    if (typeOf(ys) === '[object String]') {
      return xs + ys;
    } else {
      return xs.concat(ys);
    }
  };

  X.join = join = function(sep, xs) {
    if (typeOf(xs) === '[object Object]') {
      xs = values(xs);
    }
    return xs.join(sep);
  };

  X.reverse = reverse = function(xs) {
    if (typeOf(xs) === '[object String]') {
      return (xs.split('')).reverse().join('');
    } else {
      return xs.slice().reverse();
    }
  };

  X.fold = fold = X.foldl = foldl = function(memo, xs, f) {
    var key, x, _i, _len;
    if (typeOf(xs) === '[object Object]') {
      for (key in xs) {
        x = xs[key];
        memo = f(memo, x);
      }
    } else {
      for (_i = 0, _len = xs.length; _i < _len; _i++) {
        x = xs[_i];
        memo = f(memo, x);
      }
    }
    return memo;
  };

  X.fold1 = fold1 = X.foldl1 = foldl1 = function(xs, f) {
    return fold(xs[0], xs.slice(1), f);
  };

  X.foldr = foldr = function(memo, xs, f) {
    return fold(memo, xs.slice().reverse(), f);
  };

  X.foldr1 = foldr1 = function(xs, f) {
    xs = xs.slice().reverse();
    return fold(xs[0], xs.slice(1), f);
  };

  X.unfoldr = unfoldr = X.unfold = unfold = function(b, f) {
    var that, _results;
    _results = [];
    while ((that = f(b)) != null) {
      b = that[1];
      _results.push(that[0]);
    }
    return _results;
  };

  X.andList = andList = function(xs) {
    var x, _i, _len;
    for (_i = 0, _len = xs.length; _i < _len; _i++) {
      x = xs[_i];
      if (!x) {
        return false;
      }
    }
    return true;
  };

  X.orList = orList = function(xs) {
    var x, _i, _len;
    for (_i = 0, _len = xs.length; _i < _len; _i++) {
      x = xs[_i];
      if (x) {
        return true;
      }
    }
    return false;
  };

  X.any = any = function(xs, f) {
    var x, _i, _len;
    for (_i = 0, _len = xs.length; _i < _len; _i++) {
      x = xs[_i];
      if (f(x)) {
        return true;
      }
    }
    return false;
  };

  X.all = all = function(xs, f) {
    var x, _i, _len;
    for (_i = 0, _len = xs.length; _i < _len; _i++) {
      x = xs[_i];
      if (!f(x)) {
        return false;
      }
    }
    return true;
  };

  X.unique = unique = function(xs) {
    var key, result, x, _i, _len;
    result = [];
    if (typeOf(xs) === '[object Object]') {
      for (key in xs) {
        x = xs[key];
        if (__indexOf.call(result, x) < 0) {
          result.push(x);
        }
      }
    } else {
      for (_i = 0, _len = xs.length; _i < _len; _i++) {
        x = xs[_i];
        if (__indexOf.call(result, x) < 0) {
          result.push(x);
        }
      }
    }
    if (typeOf(xs) === '[object String]') {
      return result.join('');
    } else {
      return result;
    }
  };

  X.sort = sort = function(xs) {
    return xs.slice().sort(function(x, y) {
      if (x > y) {
        return 1;
      } else if (x < y) {
        return -1;
      } else {
        return 0;
      }
    });
  };

  X.sortWith = sortWith = function(xs, f) {
    if (!xs.length) {
      return [];
    }
    return xs.slice().sort(f);
  };

  X.sortBy = sortBy = function(xs, f) {
    return sortWith(xs, compare(f));
  };

  X.compare = compare = function(fx, y, f) {
    if ((y != null) && (f != null)) {
      if ((f(fx)) > (f(y))) {
        return 1;
      } else if ((f(fx)) < (f(y))) {
        return -1;
      } else {
        return 0;
      }
    } else {
      return function(x, y) {
        if ((fx(x)) > (fx(y))) {
          return 1;
        } else if ((fx(x)) < (fx(y))) {
          return -1;
        } else {
          return 0;
        }
      };
    }
  };

  X.sum = sum = function(xs) {
    var key, result, x, _i, _len;
    result = 0;
    if (typeOf(xs) === '[object Object]') {
      for (key in xs) {
        x = xs[key];
        result += x;
      }
    } else {
      for (_i = 0, _len = xs.length; _i < _len; _i++) {
        x = xs[_i];
        result += x;
      }
    }
    return result;
  };

  X.product = product = function(xs) {
    var key, result, x, _i, _len;
    result = 1;
    if (typeOf(xs) === '[object Object]') {
      for (key in xs) {
        x = xs[key];
        result *= x;
      }
    } else {
      for (_i = 0, _len = xs.length; _i < _len; _i++) {
        x = xs[_i];
        result *= x;
      }
    }
    return result;
  };

  X.mean = mean = X.average = average = function(xs) {
    return (sum(xs)) / len(xs);
  };

  X.median = median = function(xs) {
    var mid;
    if (xs.length === 0) {
      return void 0;
    } else {
      xs = sort(xs);
      mid = div(xs.length, 2);
      if (odd(xs.length)) {
        return xs[mid];
      } else {
        return (xs[mid - 1] + xs[mid]) / 2;
      }
    }
  };

  X.concat = concat = function(xss) {
    var x, _i, _len, _ref;
    if (!xss.length) {
      return [];
    }
    for (_i = 0, _len = xss.length; _i < _len; _i++) {
      x = xss[_i];
      if (!(typeOf(x) === '[object String]')) {
        return (_ref = []).concat.apply(_ref, xss);
      }
    }
    return xss.join('');
  };

  X.concatMap = concatMap = function(xs, f) {
    return concat(map(xs, f));
  };

  X.listToObj = listToObj = function(xs) {
    var result, x, _i, _len;
    result = {};
    for (_i = 0, _len = xs.length; _i < _len; _i++) {
      x = xs[_i];
      result[x[0]] = x[1];
    }
    return result;
  };

  X.maximum = maximum = function(xs) {
    return fold1(xs, max);
  };

  X.minimum = minimum = function(xs) {
    return fold1(xs, min);
  };

  X.scan = scan = X.scanl = scanl = function(memo, xs, f) {
    var key, x;
    last = memo;
    if (typeOf(xs) === '[object Object]') {
      return [memo].concat((function() {
        var _results;
        _results = [];
        for (key in xs) {
          x = xs[key];
          _results.push(last = f(last, x));
        }
        return _results;
      })());
    } else {
      return [memo].concat((function() {
        var _i, _len, _results;
        _results = [];
        for (_i = 0, _len = xs.length; _i < _len; _i++) {
          x = xs[_i];
          _results.push(last = f(last, x));
        }
        return _results;
      })());
    }
  };

  X.scan1 = scan1 = X.scanl1 = scanl1 = function(xs, f) {
    return scan(xs[0], xs.slice(1), f);
  };

  X.scanr = scanr = function(memo, xs, f) {
    xs = xs.slice().reverse();
    return (scan(memo, xs, f)).reverse();
  };

  X.scanr1 = scanr1 = function(xs, f) {
    xs = xs.slice().reverse();
    return (scan(xs[0], xs.slice(1), f)).reverse();
  };

  X.replicate = replicate = function(n, x) {
    var i, result;
    result = [];
    i = 0;
    while (i++ < n) {
      result.push(x);
    }
    return result;
  };

  X.take = take = function(n, xs) {
    if (n <= 0) {
      if (typeOf(xs) === '[object String]') {
        return '';
      } else {
        return [];
      }
    } else if (!xs.length) {
      return xs;
    } else {
      return xs.slice(0, n);
    }
  };

  X.drop = drop = function(n, xs) {
    if (n <= 0 || !xs.length) {
      return xs;
    } else {
      return xs.slice(n);
    }
  };

  X.splitAt = splitAt = function(n, xs) {
    return [take(n, xs), drop(n, xs)];
  };

  X.takeWhile = takeWhile = function(xs, p) {
    var result, x, _i, _len;
    if (!xs.length) {
      return xs;
    }
    result = [];
    for (_i = 0, _len = xs.length; _i < _len; _i++) {
      x = xs[_i];
      if (!p(x)) {
        break;
      }
      result.push(x);
    }
    if (typeOf(xs) === '[object String]') {
      return result.join('');
    } else {
      return result;
    }
  };

  X.dropWhile = dropWhile = function(xs, p) {
    var i, x, _i, _len;
    if (!xs.length) {
      return xs;
    }
    i = 0;
    for (_i = 0, _len = xs.length; _i < _len; _i++) {
      x = xs[_i];
      if (!p(x)) {
        break;
      }
      ++i;
    }
    return xs.slice(i);
  };

  X.span = span = function(xs, p) {
    return [takeWhile(xs, p), dropWhile(xs, p)];
  };

  X.breakIt = breakIt = function(xs, p) {
    return span(xs, function(x) {
      return !p(x);
    });
  };

  X.elem = elem = function(x, ys) {
    if (ys != null) {
      return __indexOf.call(ys, x) >= 0;
    } else {
      return function(ys) {
        return __indexOf.call(ys, x) >= 0;
      };
    }
  };

  X.notElem = notElem = function(x, ys) {
    if (ys != null) {
      return !(__indexOf.call(ys, x) >= 0);
    } else {
      return function(ys) {
        return !(__indexOf.call(ys, x) >= 0);
      };
    }
  };

  X.lookup = lookup = function(key, xs) {
    return xs != null ? xs[key] : void 0;
  };

  X.call = call = function(key, xs) {
    return xs != null ? typeof xs[key] === "function" ? xs[key]() : void 0 : void 0;
  };

  X.zip = zip = function(xs, ys) {
    var i, j, result, z, zs, _i, _j, _len, _len1, _ref, _ref1;
    result = [];
    _ref = [xs, ys];
    for (i = _i = 0, _len = _ref.length; _i < _len; i = ++_i) {
      zs = _ref[i];
      for (j = _j = 0, _len1 = zs.length; _j < _len1; j = ++_j) {
        z = zs[j];
        if (i === 0) {
          result.push([]);
        }
        if ((_ref1 = result[j]) != null) {
          _ref1.push(z);
        }
      }
    }
    return result;
  };

  X.zipWith = zipWith = function(xs, ys, f) {
    var z, _i, _len, _ref, _results;
    if (!xs.length || !ys.length) {
      return [];
    } else {
      _ref = zip(xs, ys);
      _results = [];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        z = _ref[_i];
        _results.push(f.apply(null, z));
      }
      return _results;
    }
  };

  X.zipAll = zipAll = function() {
    var i, j, result, x, xs, xss, _i, _j, _len, _len1, _ref;
    xss = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
    result = [];
    for (i = _i = 0, _len = xss.length; _i < _len; i = ++_i) {
      xs = xss[i];
      for (j = _j = 0, _len1 = xs.length; _j < _len1; j = ++_j) {
        x = xs[j];
        if (i === 0) {
          result.push([]);
        }
        if ((_ref = result[j]) != null) {
          _ref.push(x);
        }
      }
    }
    return result;
  };

  X.zipAllWith = zipAllWith = function() {
    var f, xs, xss, _i, _j, _len, _ref, _results;
    xss = 2 <= arguments.length ? __slice.call(arguments, 0, _i = arguments.length - 1) : (_i = 0, []), f = arguments[_i++];
    if (!xss[0].length || !xss[1].length) {
      return [];
    } else {
      _ref = zipAll.apply(null, xss);
      _results = [];
      for (_j = 0, _len = _ref.length; _j < _len; _j++) {
        xs = _ref[_j];
        _results.push(f.apply(null, xs));
      }
      return _results;
    }
  };

  X.compose = compose = function() {
    var funcs;
    funcs = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
    return function() {
      var args, f, _i, _len;
      args = arguments;
      for (_i = 0, _len = funcs.length; _i < _len; _i++) {
        f = funcs[_i];
        args = [f.apply(this, args)];
      }
      return args[0];
    };
  };

  X.curry = curry = function(f) {
    return function() {
      var args;
      args = arguments;
      return function(x) {
        return f.apply(null, __slice.call(args).concat([x]));
      };
    };
  };

  X.partial = partial = function() {
    var f, initArgs;
    f = arguments[0], initArgs = 2 <= arguments.length ? __slice.call(arguments, 1) : [];
    return function() {
      var args;
      args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
      return f.apply(null, initArgs.concat(args));
    };
  };

  X.id = id = function(x) {
    return x;
  };

  X.flip = flip = function(f) {
    return function(x, y) {
      return f(y, x);
    };
  };

  X.fix = fix = function(f) {
    return (function(g, x) {
      return function() {
        return f(g(g)).apply(null, arguments);
      };
    })(function(g, x) {
      return function() {
        return f(g(g)).apply(null, arguments);
      };
    });
  };

  X.lines = lines = function(str) {
    if (!str.length) {
      return [];
    }
    return str.split('\n');
  };

  X.unlines = unlines = function(strs) {
    return strs.join('\n');
  };

  X.words = words = function(str) {
    if (!str.length) {
      return [];
    }
    return str.split(/[ ]+/);
  };

  X.unwords = unwords = function(strs) {
    return strs.join(' ');
  };

  X.max = max = function(x, y) {
    if (x > y) {
      return x;
    } else {
      return y;
    }
  };

  X.min = min = function(x, y) {
    if (x < y) {
      return x;
    } else {
      return y;
    }
  };

  X.negate = negate = function(x) {
    return -x;
  };

  X.abs = abs = Math.abs;

  X.signum = signum = function(x) {
    if (x < 0) {
      return -1;
    } else if (x > 0) {
      return 1;
    } else {
      return 0;
    }
  };

  X.quot = quot = function(x, y) {
    return ~~(x / y);
  };

  X.rem = rem = function(x, y) {
    return x % y;
  };

  X.div = div = function(x, y) {
    return Math.floor(x / y);
  };

  X.mod = mod = function(x, y) {
    var result;
    if ((result = x % y) < 0 && y > 0 || result > 0 && y < 0) {
      return result + y;
    } else {
      return result;
    }
  };

  X.recip = recip = function(x) {
    return 1 / x;
  };

  X.pi = pi = Math.PI;

  X.tau = tau = pi * 2;

  X.phi = phi = 1.618033988749895;

  X.exp = exp = Math.exp;

  X.sqrt = sqrt = Math.sqrt;

  X.ln = ln = Math.log;

  X.pow = pow = Math.pow;

  X.sin = sin = Math.sin;

  X.tan = tan = Math.tan;

  X.cos = cos = Math.cos;

  X.asin = asin = Math.asin;

  X.acos = acos = Math.acos;

  X.atan = atan = Math.atan;

  X.atan2 = atan2 = Math.atan2;

  X.truncate = truncate = function(x) {
    return ~~x;
  };

  X.round = round = Math.round;

  X.ceil = ceil = Math.ceil;

  X.floor = floor = Math.floor;

  X.isItNaN = isItNaN = function(x) {
    return x !== x;
  };

  X.even = even = function(x) {
    return x % 2 === 0;
  };

  X.odd = odd = function(x) {
    return x % 2 !== 0;
  };

  X.gcd = gcd = function(x, y) {
    var z;
    x = Math.abs(x);
    y = Math.abs(y);
    while (y !== 0) {
      z = x % y;
      x = y;
      y = z;
    }
    return x;
  };

  X.lcm = lcm = function(x, y) {
    return Math.abs(Math.floor(x / (gcd(x, y)) * y));
  };

  X.plus = plus = function(x, y) {
    if (y != null) {
      return x + y;
    } else {
      return function(y) {
        return x + y;
      };
    }
  };

  X.minus = minus = function(x, y) {
    if (y != null) {
      return x - y;
    } else {
      return function(y) {
        return x - y;
      };
    }
  };

  X.times = times = function(x, y) {
    if (y != null) {
      return x * y;
    } else {
      return function(y) {
        return x * y;
      };
    }
  };

  X.over = over = function(x, y) {
    if (y != null) {
      return x / y;
    } else {
      return function(y) {
        return x / y;
      };
    }
  };

  X.equals = equals = function(x, y) {
    if (y != null) {
      return x === y;
    } else {
      return function(y) {
        return x === y;
      };
    }
  };

  X.extend = extend = function(to, from) {
    var key, val, _results;
    _results = [];
    for (key in from) {
      if (!__hasProp.call(from, key)) continue;
      val = from[key];
      _results.push(to[key] = val);
    }
    return _results;
  };

  X.prelude = prelude = this;

  X.installPrelude = installPrelude = function(target) {
    var _ref;
    if (!((_ref = target.prelude) != null ? _ref.isInstalled : void 0)) {
      extend(target, X);
      return target.prelude.isInstalled = true;
    }
  };

  module.exports = X;

}).call(this);


  return module.exports;
});
})(this);